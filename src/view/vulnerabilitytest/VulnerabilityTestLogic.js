
import intl from "react-intl-universal";
import { DATE_FORMAT_LONG, formatAbsoluteDate, formatShortAbsoluteDate } from "../../helpers/DateHelper";

const TOOLSTATE_INITIALIZING = "Initializing";
const TOOLSTATE_READY = "Ready";
const TOOLSTATE_STARTING = "Starting";
const TOOLSTATE_RUNNING = "Running";
const TOOLSTATE_STOPPING = "Stopping";
const TOOLSTATE_STOPPED = "Stopped";
const TOOLSTATE_FAILED = "Failed";
const TOOLSTATE_COMPLETED = "Completed";
const TOOLSTATE_TERMINATED = "Terminated";
const TOOLSTATE_UNKNOWN = "Unknown";
const TOOLSTATE_DISCOVERY = "discovery";

export const TOPOLOGY_PUBLICINTERNET = 'PUBLICINTERNET';
export const TOPOLOGY_WAN = 'WAN';
export const TOPOLOGY_UNKNOWN = 'UNKNOWN';


function calculateTopology(result) {
    if (result.extIpInfo && result.RouterUpnpInfo && result.RouterUpnpInfo.extip && result.extIpInfo.address) {
        return result.RouterUpnpInfo.extip === result.extIpInfo.address ? 
            TOPOLOGY_PUBLICINTERNET : TOPOLOGY_WAN;
    }
    return TOPOLOGY_UNKNOWN;
}

export class VulnerabilityTestResult {

    engineState = TOOLSTATE_INITIALIZING;
    
    releaseDate
    logoImageUrl

    deviceFound = false;
    deviceBestModel
    deviceBestMake
    deviceBestFamily
    deviceMacAddress
    deviceAddressList
    isFamily = false;
    manualUrl

    portMappings

    routerHasUpnpNAT
    routerHasNatPMP
    
    topology
    topologyAddress

    lastUpdate

    isToolRunning() {
        return this.engineState === TOOLSTATE_INITIALIZING ||
            this.engineState === TOOLSTATE_STARTING ||
            this.engineState === TOOLSTATE_RUNNING ||
            this.engineState === TOOLSTATE_DISCOVERY ||
            this.engineState === TOOLSTATE_STOPPING;
    }
    
    isToolStopped() {
        return this.engineState === TOOLSTATE_FAILED ||
            this.engineState === TOOLSTATE_COMPLETED ||
            this.engineState === TOOLSTATE_TERMINATED ||
            this.engineState === TOOLSTATE_READY ||
            this.engineState === TOOLSTATE_UNKNOWN;
    }

    getDeviceMacAddress(){
        return this.deviceMacAddress || '';
    }
    getDeviceAddressList(){
        return this.deviceAddressList && this.deviceAddressList.length > 0 ? this.deviceAddressList[0] : '';
    }
    getDeviceBestMake(){
        return this.deviceBestMake || '';
    }
}

/**
 * Converts the given speedTest object into a list of items to display.
 * @param htcRecord The object from the vulnerability tool result
 * @param deviceDetail The object from device's data
 * @returns {VulnerabilityTestResult} A speed test state result object
 */
export function convertToVulnerabilityTestResult(htcRecord, deviceDetail) {
    const testResult = new VulnerabilityTestResult();
    const result = htcRecord.result
    const recogCatalog = deviceDetail && deviceDetail.recogCatalog ? deviceDetail.recogCatalog : null;
    testResult.engineState = htcRecord.tool_state

    testResult.portMappings = result && result.routerInfoAudit && result.routerInfoAudit.RouterUpnpInfo && result.routerInfoAudit.RouterUpnpInfo.portMappings ? result.routerInfoAudit.RouterUpnpInfo.portMappings : [];
    testResult.routerHasUpnpNAT = result && result.routerInfoAudit && result.routerInfoAudit.RouterUpnpInfo && result.routerInfoAudit.RouterUpnpInfo.extip;
    testResult.routerHasNatPMP = result && result.routerInfoAudit && result.routerInfoAudit.RouterNatInfo && result.routerInfoAudit.RouterNatInfo.extip;

    testResult.lastUpdate = intl.get('routercheck_last_update', { date:formatAbsoluteDate(result.timestamp, DATE_FORMAT_LONG)});
    testResult.topology = calculateTopology(result);
    if (result.extIpInfo && result.extIpInfo.address) {
        testResult.topologyAddress = intl.get('routercheck_internet_address', { address: result.extIpInfo.address })
    }

    let releaseDate = null;
    if (recogCatalog && recogCatalog.recogDevice && recogCatalog.recogDevice.releaseDate) {
        releaseDate = formatShortAbsoluteDate(recogCatalog.recogDevice.releaseDate);
        if (recogCatalog.recogDevice.discDate) {
            releaseDate += ' - ' + formatShortAbsoluteDate(recogCatalog.recogDevice.discDate);
        } else {
            releaseDate += ' - ' + intl.get('dateformat_now');
        }
    }

    testResult.releaseDate = releaseDate;

    let logoImageUrl = null;
    if (recogCatalog && recogCatalog.recogMake) {
        if (recogCatalog.recogMake.bannerImageUrl) logoImageUrl = recogCatalog.recogMake.bannerImageUrl;
        else if (recogCatalog.recogMake.logoImageUrl) logoImageUrl = recogCatalog.recogMake.logoImageUrl;
    }

    testResult.logoImageUrl = logoImageUrl;

    const device = result && result.routerInfoAudit && result.routerInfoAudit.router;
    if(device){
        testResult.isFamily = device.isFamily && device.isFamily === 'true';
        if(device.best_model)
            testResult.deviceBestModel = device.best_model;
        if(device.best_make)
            testResult.deviceBestMake = device.best_make;
        if(device.address_list)
            testResult.deviceAddressList = device.address_list;
        if(device.mac_address)
            testResult.deviceMacAddress = device.mac_address;
        if(device.best_family)
            testResult.deviceBestFamily = device.best_family;
    }
    

    testResult.manualUrl = recogCatalog && recogCatalog.recogDevice && recogCatalog.recogDevice.manualUrl ? recogCatalog.recogDevice.manualUrl : null;
    return testResult;
}

        



        

